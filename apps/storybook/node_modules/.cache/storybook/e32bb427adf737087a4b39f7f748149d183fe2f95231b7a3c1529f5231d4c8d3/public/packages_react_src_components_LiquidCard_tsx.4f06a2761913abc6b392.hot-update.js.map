{"version":3,"file":"packages_react_src_components_LiquidCard_tsx.4f06a2761913abc6b392.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AAiBA;;;;;AAKA;AA2BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AAQA;AAGA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAGA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAKA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAIA;AAGA;AAGA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAGA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAGA;AAEA;AAEA;AACA;AACA;AACA;AACA;;AAGA","sources":["webpack://@liquid-ui/storybook/../../packages/react/src/components/LiquidCard.tsx"],"sourcesContent":["import React, { forwardRef, useRef, useCallback, useState, useEffect } from 'react'\nimport { clsx } from 'clsx'\nimport { useLiquidGlass } from '../hooks/useLiquidGlass'\nimport { useInteractiveGlass } from '../hooks/useInteractiveGlass'\nimport type { LiquidCardProps, LiquidCardComponent } from '../types'\n\ninterface DragState {\n  isDragging: boolean\n  startX: number\n  startY: number\n  currentX: number\n  currentY: number\n}\n\ninterface MagneticEffect {\n  x: number\n  y: number\n  intensity: number\n}\n\n/**\n * LiquidCard - The signature Liquid UI component\n * \n * A beautiful glass card with Apple-style liquid glass effects, perfect physics,\n * and smooth animations. This is the cornerstone component of Liquid UI.\n */\nconst LiquidCardBase = forwardRef<HTMLDivElement, LiquidCardProps>(\n  (\n    {\n      variant = 'frosted',\n      intensity = 'regular',\n      opacity = 'regular',\n      interactive = true,\n      adaptiveOpacity = false,\n      environmentBlending = false,\n      hover = true,\n      shadow = true,\n      border = true,\n      className,\n      children,\n      onHover,\n      onLiquidDragStart,\n      onLiquidDrag,\n      onLiquidDragEnd,\n      draggable = false,\n      magneticEdges = false,\n      magneticStrength = 0.3,\n      style,\n      ...rest\n    },\n    ref\n  ) => {\n    const [isHovered, setIsHovered] = useState(false)\n    const [dragState, setDragState] = useState<DragState>({\n      isDragging: false,\n      startX: 0,\n      startY: 0,\n      currentX: 0,\n      currentY: 0\n    })\n    const [magneticEffect, setMagneticEffect] = useState<MagneticEffect>({ x: 0, y: 0, intensity: 0 })\n    const [shadowDepth, setShadowDepth] = useState(0)\n    const cardRef = useRef<HTMLDivElement>(null)\n    const containerRef = useRef<HTMLDivElement>(null)\n    \n    // Use our custom hooks for glass effects\n    const glassStyles = useLiquidGlass({\n      variant,\n      intensity,\n      opacity,\n      interactive,\n      adaptiveOpacity,\n      environmentBlending\n    })\n    \n    const { handleMouseEnter, handleMouseLeave, handleMouseMove } = useInteractiveGlass({\n      elementRef: cardRef,\n      enabled: interactive && hover && !dragState.isDragging,\n      onHover: (hovered) => {\n        setIsHovered(hovered)\n        onHover?.(hovered)\n        if (hovered) {\n          setShadowDepth(1)\n        } else {\n          setShadowDepth(0)\n        }\n      }\n    })\n    \n    // Magnetic edges effect\n    useEffect(() => {\n      if (!magneticEdges || !isHovered || dragState.isDragging) return\n      \n      const handleMagneticMove = (e: MouseEvent) => {\n        const card = cardRef.current\n        if (!card) return\n        \n        const rect = card.getBoundingClientRect()\n        const centerX = rect.left + rect.width / 2\n        const centerY = rect.top + rect.height / 2\n        \n        const deltaX = e.clientX - centerX\n        const deltaY = e.clientY - centerY\n        \n        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY)\n        const maxDistance = Math.max(rect.width, rect.height) / 2\n        \n        if (distance < maxDistance) {\n          const intensity = (1 - distance / maxDistance) * magneticStrength\n          setMagneticEffect({\n            x: deltaX * intensity * 0.1,\n            y: deltaY * intensity * 0.1,\n            intensity\n          })\n        } else {\n          setMagneticEffect({ x: 0, y: 0, intensity: 0 })\n        }\n      }\n      \n      document.addEventListener('mousemove', handleMagneticMove)\n      return () => document.removeEventListener('mousemove', handleMagneticMove)\n    }, [magneticEdges, isHovered, dragState.isDragging, magneticStrength])\n    \n    // Drag functionality\n    const handleDragStart = useCallback((e: React.MouseEvent | React.TouchEvent) => {\n      if (!draggable) return\n      \n      e.preventDefault()\n      const clientX = 'touches' in e ? e.touches[0].clientX : e.clientX\n      const clientY = 'touches' in e ? e.touches[0].clientY : e.clientY\n      \n      setDragState({\n        isDragging: true,\n        startX: clientX,\n        startY: clientY,\n        currentX: 0,\n        currentY: 0\n      })\n      \n      setShadowDepth(2)\n      onLiquidDragStart?.(e)\n    }, [draggable, onLiquidDragStart])\n    \n    const handleDragMove = useCallback((e: MouseEvent | TouchEvent) => {\n      if (!dragState.isDragging) return\n      \n      const clientX = 'touches' in e ? e.touches[0].clientX : e.clientX\n      const clientY = 'touches' in e ? e.touches[0].clientY : e.clientY\n      \n      const deltaX = clientX - dragState.startX\n      const deltaY = clientY - dragState.startY\n      \n      setDragState(prev => ({\n        ...prev,\n        currentX: deltaX,\n        currentY: deltaY\n      }))\n      \n      onLiquidDrag?.(e, { x: deltaX, y: deltaY })\n    }, [dragState.isDragging, dragState.startX, dragState.startY, onLiquidDrag])\n    \n    const handleDragEnd = useCallback((e: MouseEvent | TouchEvent) => {\n      if (!dragState.isDragging) return\n      \n      setDragState({\n        isDragging: false,\n        startX: 0,\n        startY: 0,\n        currentX: 0,\n        currentY: 0\n      })\n      \n      setShadowDepth(0)\n      setMagneticEffect({ x: 0, y: 0, intensity: 0 })\n      onLiquidDragEnd?.(e)\n    }, [dragState.isDragging, onLiquidDragEnd])\n    \n    // Global drag event listeners\n    useEffect(() => {\n      if (dragState.isDragging) {\n        document.addEventListener('mousemove', handleDragMove)\n        document.addEventListener('mouseup', handleDragEnd)\n        document.addEventListener('touchmove', handleDragMove)\n        document.addEventListener('touchend', handleDragEnd)\n        \n        return () => {\n          document.removeEventListener('mousemove', handleDragMove)\n          document.removeEventListener('mouseup', handleDragEnd)\n          document.removeEventListener('touchmove', handleDragMove)\n          document.removeEventListener('touchend', handleDragEnd)\n        }\n      }\n    }, [dragState.isDragging, handleDragMove, handleDragEnd])\n    \n    // Combine all mouse event handlers\n    const onMouseEnter = useCallback((e: React.MouseEvent) => {\n      if (!dragState.isDragging) {\n        handleMouseEnter()\n      }\n      rest.onMouseEnter?.(e as any)\n    }, [handleMouseEnter, rest.onMouseEnter, dragState.isDragging])\n    \n    const onMouseLeave = useCallback((e: React.MouseEvent) => {\n      if (!dragState.isDragging) {\n        handleMouseLeave()\n        setMagneticEffect({ x: 0, y: 0, intensity: 0 })\n      }\n      rest.onMouseLeave?.(e as any)\n    }, [handleMouseLeave, rest.onMouseLeave, dragState.isDragging])\n    \n    const onMouseMove = useCallback((e: React.MouseEvent) => {\n      if (!dragState.isDragging) {\n        handleMouseMove(e as React.MouseEvent<HTMLDivElement>)\n      }\n      rest.onMouseMove?.(e as any)\n    }, [handleMouseMove, rest.onMouseMove, dragState.isDragging])\n    \n    const onMouseDown = useCallback((e: React.MouseEvent) => {\n      handleDragStart(e)\n      rest.onMouseDown?.(e as any)\n    }, [handleDragStart, rest.onMouseDown])\n    \n    const onTouchStart = useCallback((e: React.TouchEvent) => {\n      handleDragStart(e)\n      rest.onTouchStart?.(e as any)\n    }, [handleDragStart, rest.onTouchStart])\n    \n    // Build CSS classes\n    const classes = clsx(\n      // Base glass card styles\n      'liquid-card',\n      'relative',\n      'overflow-hidden',\n      'transition-all',\n      'duration-200',\n      'ease-out',\n      \n      // Border styles\n      border && 'border border-white/10',\n      \n      // Dynamic shadow styles based on depth\n      shadow && [\n        shadowDepth === 0 && 'shadow-lg',\n        shadowDepth === 1 && 'shadow-xl',\n        shadowDepth === 2 && 'shadow-2xl',\n        dragState.isDragging && 'shadow-2xl shadow-blue-500/25'\n      ],\n      \n      // Interactive styles\n      interactive && [\n        !dragState.isDragging && 'cursor-pointer',\n        'transform-gpu',\n        !dragState.isDragging && 'transition-all',\n        !dragState.isDragging && 'duration-300',\n        !dragState.isDragging && 'ease-out'\n      ],\n      \n      // Draggable styles\n      draggable && [\n        'select-none',\n        dragState.isDragging && [\n          'cursor-grabbing',\n          'scale-105',\n          'rotate-1',\n          'z-50'\n        ],\n        !dragState.isDragging && draggable && 'cursor-grab'\n      ],\n      \n      // Custom className\n      className\n    )\n    \n    // Merge styles with transforms\n    const transformStyles = {\n      transform: dragState.isDragging \n        ? `translate3d(${dragState.currentX + magneticEffect.x}px, ${dragState.currentY + magneticEffect.y}px, 0px)` \n        : magneticEffect.intensity > 0 \n        ? `translate3d(${magneticEffect.x}px, ${magneticEffect.y}px, 0px) ${isHovered ? 'scale(1.02)' : ''}`\n        : isHovered && !dragState.isDragging ? 'scale(1.02)' : 'none',\n      filter: [\n        (glassStyles as any).filter || '',\n        dragState.isDragging ? 'brightness(1.1)' : '',\n        magneticEffect.intensity > 0 ? `hue-rotate(${magneticEffect.intensity * 10}deg)` : ''\n      ].filter(Boolean).join(' '),\n      transition: dragState.isDragging ? 'none' : 'transform 0.3s cubic-bezier(0.2, 0, 0.2, 1), filter 0.2s ease',\n      willChange: dragState.isDragging ? 'transform' : 'auto'\n    }\n    \n    const combinedStyles = {\n      ...glassStyles,\n      ...transformStyles,\n      ...style\n    }\n    \n    return (\n      <div\n        ref={(node: HTMLDivElement | null) => {\n          // Handle both forwarded ref and internal ref\n          if (typeof ref === 'function') {\n            ref(node)\n          } else if (ref) {\n            (ref as React.MutableRefObject<HTMLDivElement | null>).current = node\n          }\n          if (cardRef.current !== node) {\n            (cardRef as React.MutableRefObject<HTMLDivElement | null>).current = node\n          }\n        }}\n        className={classes}\n        style={combinedStyles}\n        onMouseEnter={onMouseEnter}\n        onMouseLeave={onMouseLeave}\n        onMouseMove={onMouseMove}\n        onMouseDown={onMouseDown}\n        onTouchStart={onTouchStart}\n        draggable={false}\n        {...rest}\n      >\n        {/* Magnetic field visualization */}\n        {magneticEdges && magneticEffect.intensity > 0 && (\n          <div \n            className=\"absolute inset-0 rounded-inherit pointer-events-none\"\n            style={{\n              background: `radial-gradient(circle at center, \n                rgba(59, 130, 246, ${magneticEffect.intensity * 0.1}) 0%, \n                transparent 70%\n              )`,\n              opacity: magneticEffect.intensity\n            }}\n          />\n        )}\n        \n        {/* Drag indicator */}\n        {draggable && isHovered && !dragState.isDragging && (\n          <div className=\"absolute top-2 right-2 opacity-50 pointer-events-none\">\n            <svg className=\"w-4 h-4 text-white\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12\" />\n            </svg>\n          </div>\n        )}\n        {children}\n      </div>\n    )\n  }\n)\n\nLiquidCardBase.displayName = 'LiquidCard'\n\n// Create the main component with proper typing\nexport const LiquidCard = LiquidCardBase as LiquidCardComponent\n\n// Preset components for easier usage\nLiquidCard.Frosted = forwardRef<HTMLDivElement, Omit<LiquidCardProps, 'variant' | 'intensity' | 'interactive' | 'hover' | 'shadow'>>((props, ref) => (\n  <LiquidCardBase\n    ref={ref}\n    variant=\"frosted\"\n    intensity=\"regular\"\n    interactive\n    hover\n    shadow\n    {...props}\n  />\n))\nLiquidCard.Frosted.displayName = 'LiquidCard.Frosted'\n\nLiquidCard.Clear = forwardRef<HTMLDivElement, Omit<LiquidCardProps, 'variant' | 'opacity' | 'interactive' | 'hover'>>((props, ref) => (\n  <LiquidCardBase\n    ref={ref}\n    variant=\"clear\"\n    opacity=\"light\"\n    interactive\n    hover\n    {...props}\n  />\n))\nLiquidCard.Clear.displayName = 'LiquidCard.Clear'\n\nLiquidCard.Tinted = forwardRef<HTMLDivElement, Omit<LiquidCardProps, 'variant' | 'intensity' | 'interactive' | 'hover' | 'shadow'>>((props, ref) => (\n  <LiquidCardBase\n    ref={ref}\n    variant=\"tinted\"\n    intensity=\"regular\"\n    interactive\n    hover\n    shadow\n    {...props}\n  />\n))\nLiquidCard.Tinted.displayName = 'LiquidCard.Tinted'\n\nLiquidCard.Interactive = forwardRef<HTMLDivElement, Omit<LiquidCardProps, 'interactive' | 'hover' | 'shadow' | 'border'>>((props, ref) => (\n  <LiquidCardBase\n    ref={ref}\n    interactive\n    hover\n    shadow\n    border\n    {...props}\n  />\n))\nLiquidCard.Interactive.displayName = 'LiquidCard.Interactive'\n\nLiquidCard.Static = forwardRef<HTMLDivElement, Omit<LiquidCardProps, 'interactive' | 'hover' | 'shadow'>>((props, ref) => (\n  <LiquidCardBase\n    ref={ref}\n    interactive={false}\n    hover={false}\n    shadow={false}\n    {...props}\n  />\n))\nLiquidCard.Static.displayName = 'LiquidCard.Static'"],"names":[],"sourceRoot":""}