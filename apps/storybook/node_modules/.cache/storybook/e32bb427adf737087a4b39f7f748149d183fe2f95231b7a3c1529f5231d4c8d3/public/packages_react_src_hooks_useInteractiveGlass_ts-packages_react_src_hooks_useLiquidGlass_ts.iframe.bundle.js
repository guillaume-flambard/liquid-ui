"use strict";
(self["webpackChunk_liquid_ui_storybook"] = self["webpackChunk_liquid_ui_storybook"] || []).push([["packages_react_src_hooks_useInteractiveGlass_ts-packages_react_src_hooks_useLiquidGlass_ts"],{

/***/ "../../packages/core/src/engine.ts":
/*!*****************************************!*\
  !*** ../../packages/core/src/engine.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LiquidGlassEngine: () => (/* binding */ LiquidGlassEngine)
/* harmony export */ });
/* harmony import */ var _tokens__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tokens */ "../../packages/core/src/tokens.ts");

/**
 * LiquidGlassEngine - The core engine for Apple-style liquid glass effects
 * 
 * This class implements Apple's exact liquid glass specifications including:
 * - Real-time refraction physics based on mouse position
 * - Adaptive opacity based on background luminance
 * - Performance-optimized CSS generation
 * - Cross-browser fallbacks
 */ class LiquidGlassEngine {
    static instance;
    deviceCapabilities;
    constructor(){
        this.deviceCapabilities = this.detectDeviceCapabilities();
    }
    static getInstance() {
        if (!LiquidGlassEngine.instance) {
            LiquidGlassEngine.instance = new LiquidGlassEngine();
        }
        return LiquidGlassEngine.instance;
    }
    /**
   * Calculate refraction intensity based on mouse position
   * Uses Apple's official formula: 1.0 - normalizedDist²
   */ calculateRefraction(mousePosition, elementBounds) {
        const centerX = elementBounds.x + elementBounds.width / 2;
        const centerY = elementBounds.y + elementBounds.height / 2;
        const deltaX = mousePosition.x - centerX;
        const deltaY = mousePosition.y - centerY;
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        const maxDistance = Math.sqrt((elementBounds.width / 2) ** 2 + (elementBounds.height / 2) ** 2);
        const normalizedDistance = Math.min(distance / maxDistance, 1);
        // Apple's refraction formula
        return 1.0 - Math.pow(normalizedDistance, 2);
    }
    /**
   * Generate optimized CSS properties for liquid glass effect
   */ generateGlassCSS(config) {
        const { glass } = _tokens__WEBPACK_IMPORTED_MODULE_0__.liquidTokens;
        const blurValue = this.getBlurValue(config);
        const backgroundValue = this.getBackgroundValue(config);
        const borderValue = this.getBorderValue(config);
        const shadowValue = this.getShadowValue(config);
        const styles = {
            backdropFilter: `blur(${blurValue})`,
            background: backgroundValue
        };
        // Add optional properties
        if (borderValue) styles.border = borderValue;
        if (shadowValue) styles.boxShadow = shadowValue;
        // Add fallbacks for unsupported browsers
        if (!this.deviceCapabilities.supportsBackdropFilter) {
            styles.background = this.getFallbackBackground(config);
        }
        return styles;
    }
    /**
   * Get adaptive background based on environment luminance
   */ getAdaptiveBackground(config, backgroundLuminance) {
        const { glass } = _tokens__WEBPACK_IMPORTED_MODULE_0__.liquidTokens;
        const baseColor = glass.colors[config.variant];
        // Adjust opacity based on background brightness
        const luminanceMultiplier = backgroundLuminance > 0.5 ? 0.8 : 1.2;
        const adaptiveOpacity = glass.opacity[config.opacity] * luminanceMultiplier;
        return this.adjustOpacity(baseColor, adaptiveOpacity);
    }
    /**
   * Detect device capabilities for performance optimization
   * Returns consistent values for SSR compatibility
   */ detectDeviceCapabilities() {
        if (typeof window === 'undefined') {
            // Server-side rendering fallback - assume modern browser support
            return {
                supportsBackdropFilter: true,
                performanceLevel: 'medium',
                reducedMotion: false
            };
        }
        const testElement = document.createElement('div');
        testElement.style.backdropFilter = 'blur(1px)';
        const supportsBackdropFilter = testElement.style.backdropFilter !== '';
        // Detect reduced motion preference
        const reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        // Simple performance detection based on device memory and connection
        const performanceLevel = this.detectPerformanceLevel();
        return {
            supportsBackdropFilter,
            performanceLevel,
            reducedMotion
        };
    }
    detectPerformanceLevel() {
        if (typeof navigator === 'undefined') return 'medium';
        // Check device memory (if available)
        const deviceMemory = navigator.deviceMemory;
        if (deviceMemory) {
            if (deviceMemory <= 2) return 'low';
            if (deviceMemory >= 8) return 'high';
        }
        // Check connection (if available)
        const connection = navigator.connection;
        if (connection) {
            if (connection.effectiveType === '2g' || connection.effectiveType === 'slow-2g') {
                return 'low';
            }
            if (connection.effectiveType === '4g') {
                return 'high';
            }
        }
        return 'medium';
    }
    getBlurValue(config) {
        const { glass } = _tokens__WEBPACK_IMPORTED_MODULE_0__.liquidTokens;
        // Reduce blur on low-performance devices
        if (this.deviceCapabilities.performanceLevel === 'low') {
            return glass.blur.subtle;
        }
        return glass.blur[config.intensity];
    }
    getBackgroundValue(config) {
        const { glass } = _tokens__WEBPACK_IMPORTED_MODULE_0__.liquidTokens;
        const baseColor = glass.colors[config.variant] || glass.colors.frosted;
        const opacity = glass.opacity[config.opacity] || glass.opacity.regular;
        return this.adjustOpacity(baseColor, opacity);
    }
    getBorderValue(config) {
        const { glass } = _tokens__WEBPACK_IMPORTED_MODULE_0__.liquidTokens;
        if (config.variant === 'clear') return undefined;
        return glass.border.subtle;
    }
    getShadowValue(config) {
        const { glass } = _tokens__WEBPACK_IMPORTED_MODULE_0__.liquidTokens;
        if (this.deviceCapabilities.performanceLevel === 'low') {
            return undefined // Skip shadows on low-performance devices
            ;
        }
        switch(config.opacity){
            case 'light':
                return glass.shadow.subtle;
            case 'regular':
                return glass.shadow.regular;
            case 'strong':
                return glass.shadow.strong;
            default:
                return glass.shadow.regular;
        }
    }
    getFallbackBackground(config) {
        // Fallback for browsers that don't support backdrop-filter
        const { glass } = _tokens__WEBPACK_IMPORTED_MODULE_0__.liquidTokens;
        const fallbackOpacity = (glass.opacity[config.opacity] || glass.opacity.regular) * 1.5 // Increase opacity for visibility
        ;
        switch(config.variant){
            case 'clear':
                return `rgba(255, 255, 255, ${fallbackOpacity})`;
            case 'frosted':
                return `rgba(248, 250, 252, ${fallbackOpacity})`;
            case 'tinted':
                return `rgba(219, 234, 254, ${fallbackOpacity})`;
            case 'dark':
                return `rgba(15, 23, 42, ${fallbackOpacity})`;
            case 'aurora':
                return `rgba(147, 51, 234, ${fallbackOpacity})`;
            case 'solid':
                return `rgba(255, 255, 255, ${Math.min(fallbackOpacity * 2, 0.95)})`;
            default:
                return `rgba(255, 255, 255, ${fallbackOpacity})`;
        }
    }
    adjustOpacity(colorString, newOpacity) {
        if (!colorString) return `rgba(255, 255, 255, ${newOpacity})`;
        // Extract rgba values and replace opacity
        const rgbaMatch = colorString.match(/rgba?\(([^)]+)\)/);
        if (!rgbaMatch) return colorString;
        const values = rgbaMatch[1].split(',').map((v)=>v.trim());
        if (values.length >= 3) {
            return `rgba(${values[0]}, ${values[1]}, ${values[2]}, ${newOpacity})`;
        }
        return colorString;
    }
}


/***/ }),

/***/ "../../packages/core/src/index.ts":
/*!****************************************!*\
  !*** ../../packages/core/src/index.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LiquidGlassEngine: () => (/* reexport safe */ _engine__WEBPACK_IMPORTED_MODULE_1__.LiquidGlassEngine),
/* harmony export */   PerformanceMonitor: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_2__.PerformanceMonitor),
/* harmony export */   appleEasing: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_2__.appleEasing),
/* harmony export */   calculateLuminance: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_2__.calculateLuminance),
/* harmony export */   debounce: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_2__.debounce),
/* harmony export */   easeOutCubic: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_2__.easeOutCubic),
/* harmony export */   generateCSSCustomProperties: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_2__.generateCSSCustomProperties),
/* harmony export */   getDistanceFromCenter: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_2__.getDistanceFromCenter),
/* harmony export */   getElementBounds: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_2__.getElementBounds),
/* harmony export */   isInViewport: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_2__.isInViewport),
/* harmony export */   lerp: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_2__.lerp),
/* harmony export */   liquidTokens: () => (/* reexport safe */ _tokens__WEBPACK_IMPORTED_MODULE_0__.liquidTokens),
/* harmony export */   normalize: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_2__.normalize),
/* harmony export */   parseColor: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_2__.parseColor),
/* harmony export */   throttle: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_2__.throttle)
/* harmony export */ });
/* harmony import */ var _tokens__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tokens */ "../../packages/core/src/tokens.ts");
/* harmony import */ var _engine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./engine */ "../../packages/core/src/engine.ts");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "../../packages/core/src/utils.ts");






/***/ }),

/***/ "../../packages/core/src/tokens.ts":
/*!*****************************************!*\
  !*** ../../packages/core/src/tokens.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   liquidTokens: () => (/* binding */ liquidTokens)
/* harmony export */ });
/**
 * Liquid UI Design Tokens
 * Based on Apple's Liquid Glass specifications
 */ const liquidTokens = {
    glass: {
        blur: {
            subtle: '5px',
            regular: '12px',
            strong: '20px',
            none: '0px' // Disable blur (fallback)
        },
        opacity: {
            light: 0.15,
            regular: 0.25,
            medium: 0.45,
            strong: 0.85 // 85% - Apple maximum for glass
        },
        physics: {
            // Official Apple refraction formula: 1.0 - normalizedDist²
            refraction: 'cubic-bezier(0.23, 1, 0.32, 1)',
            spring: {
                tension: 300,
                friction: 30
            },
            hover: {
                duration: '0.2s',
                easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'
            }
        },
        colors: {
            // Glass tint colors for different variants
            clear: 'rgba(255, 255, 255, 0)',
            frosted: 'rgba(255, 255, 255, 0.1)',
            tinted: 'rgba(0, 122, 255, 0.1)',
            dark: 'rgba(0, 0, 0, 0.1)',
            aurora: 'rgba(147, 51, 234, 0.1)',
            solid: 'rgba(255, 255, 255, 0.95)' // Nearly opaque for solid
        },
        border: {
            subtle: '1px solid rgba(255, 255, 255, 0.1)',
            regular: '1px solid rgba(255, 255, 255, 0.2)',
            strong: '1px solid rgba(255, 255, 255, 0.3)'
        },
        shadow: {
            subtle: '0 4px 16px rgba(0, 0, 0, 0.1)',
            regular: '0 8px 32px rgba(0, 0, 0, 0.15)',
            strong: '0 16px 64px rgba(0, 0, 0, 0.2)'
        }
    },
    spacing: {
        xs: '0.25rem',
        sm: '0.5rem',
        md: '1rem',
        lg: '1.5rem',
        xl: '2rem',
        xxl: '3rem' // 48px
    },
    borderRadius: {
        sm: '0.375rem',
        md: '0.5rem',
        lg: '0.75rem',
        xl: '1rem',
        xxl: '1.5rem',
        full: '9999px'
    },
    typography: {
        fontFamily: {
            system: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif'
        },
        fontSize: {
            xs: '0.75rem',
            sm: '0.875rem',
            base: '1rem',
            lg: '1.125rem',
            xl: '1.25rem',
            xxl: '1.5rem'
        },
        fontWeight: {
            normal: 400,
            medium: 500,
            semibold: 600,
            bold: 700
        }
    }
};


/***/ }),

/***/ "../../packages/core/src/utils.ts":
/*!****************************************!*\
  !*** ../../packages/core/src/utils.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PerformanceMonitor: () => (/* binding */ PerformanceMonitor),
/* harmony export */   appleEasing: () => (/* binding */ appleEasing),
/* harmony export */   calculateLuminance: () => (/* binding */ calculateLuminance),
/* harmony export */   debounce: () => (/* binding */ debounce),
/* harmony export */   easeOutCubic: () => (/* binding */ easeOutCubic),
/* harmony export */   generateCSSCustomProperties: () => (/* binding */ generateCSSCustomProperties),
/* harmony export */   getDistanceFromCenter: () => (/* binding */ getDistanceFromCenter),
/* harmony export */   getElementBounds: () => (/* binding */ getElementBounds),
/* harmony export */   isInViewport: () => (/* binding */ isInViewport),
/* harmony export */   lerp: () => (/* binding */ lerp),
/* harmony export */   normalize: () => (/* binding */ normalize),
/* harmony export */   parseColor: () => (/* binding */ parseColor),
/* harmony export */   throttle: () => (/* binding */ throttle)
/* harmony export */ });
/**
 * Utility functions for liquid glass calculations and optimizations
 */ /**
 * Calculate distance between two points
 */ function getDistanceFromCenter(point, bounds) {
    const centerX = bounds.x + bounds.width / 2;
    const centerY = bounds.y + bounds.height / 2;
    const deltaX = point.x - centerX;
    const deltaY = point.y - centerY;
    return Math.sqrt(deltaX * deltaX + deltaY * deltaY);
}
/**
 * Normalize a value between 0 and 1
 */ function normalize(value, min, max) {
    return Math.max(0, Math.min(1, (value - min) / (max - min)));
}
/**
 * Linear interpolation between two values
 */ function lerp(start, end, t) {
    return start + (end - start) * t;
}
/**
 * Apply easing function to a normalized value (0-1)
 */ function easeOutCubic(t) {
    return 1 - Math.pow(1 - t, 3);
}
/**
 * Apply Apple's signature easing curve
 */ function appleEasing(t) {
    // Cubic bezier (0.23, 1, 0.32, 1) approximation
    return t * t * (3 - 2 * t);
}
/**
 * Calculate background luminance for adaptive opacity
 */ function calculateLuminance(r, g, b) {
    // Convert to relative luminance using sRGB coefficients
    const [rs, gs, bs] = [
        r,
        g,
        b
    ].map((c)=>{
        c = c / 255;
        return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
    });
    return 0.2126 * rs + 0.7152 * gs + 0.0722 * bs;
}
/**
 * Debounce function for performance optimization
 */ function debounce(func, wait) {
    let timeout;
    return (...args)=>{
        clearTimeout(timeout);
        timeout = setTimeout(()=>func(...args), wait);
    };
}
/**
 * Throttle function for smooth animations
 */ function throttle(func, limit) {
    let inThrottle;
    return (...args)=>{
        if (!inThrottle) {
            func(...args);
            inThrottle = true;
            setTimeout(()=>inThrottle = false, limit);
        }
    };
}
/**
 * Check if an element is in viewport
 */ function isInViewport(element) {
    const rect = element.getBoundingClientRect();
    return rect.top >= 0 && rect.left >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && rect.right <= (window.innerWidth || document.documentElement.clientWidth);
}
/**
 * Get element bounds relative to viewport
 */ function getElementBounds(element) {
    const rect = element.getBoundingClientRect();
    return {
        x: rect.left,
        y: rect.top,
        width: rect.width,
        height: rect.height
    };
}
/**
 * Convert CSS color string to RGB values
 */ function parseColor(colorString) {
    // Handle rgba/rgb format
    const rgbaMatch = colorString.match(/rgba?\(([^)]+)\)/);
    if (rgbaMatch) {
        const values = rgbaMatch[1].split(',').map((v)=>parseInt(v.trim(), 10));
        if (values.length >= 3) {
            return {
                r: values[0],
                g: values[1],
                b: values[2]
            };
        }
    }
    // Handle hex format
    const hexMatch = colorString.match(/^#([a-f\d]{6})$/i);
    if (hexMatch) {
        const hex = hexMatch[1];
        return {
            r: parseInt(hex.substr(0, 2), 16),
            g: parseInt(hex.substr(2, 2), 16),
            b: parseInt(hex.substr(4, 2), 16)
        };
    }
    return null;
}
/**
 * Generate CSS custom properties object from tokens
 */ function generateCSSCustomProperties(tokens, prefix = '--liquid') {
    const properties = {};
    function flatten(obj, path = []) {
        for (const [key, value] of Object.entries(obj)){
            const currentPath = [
                ...path,
                key
            ];
            if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                flatten(value, currentPath);
            } else {
                const propertyName = `${prefix}-${currentPath.join('-')}`;
                properties[propertyName] = String(value);
            }
        }
    }
    flatten(tokens);
    return properties;
}
/**
 * Performance monitor for development
 */ class PerformanceMonitor {
    measurements = new Map();
    start(label) {
        if (typeof performance !== 'undefined') {
            performance.mark(`${label}-start`);
        }
    }
    end(label) {
        if (typeof performance === 'undefined') return 0;
        performance.mark(`${label}-end`);
        performance.measure(label, `${label}-start`, `${label}-end`);
        const entries = performance.getEntriesByName(label, 'measure');
        if (entries.length > 0) {
            const duration = entries[entries.length - 1].duration;
            // Store measurement for analysis
            if (!this.measurements.has(label)) {
                this.measurements.set(label, []);
            }
            this.measurements.get(label).push(duration);
            return duration;
        }
        return 0;
    }
    getAverageTime(label) {
        const times = this.measurements.get(label);
        if (!times || times.length === 0) return 0;
        return times.reduce((sum, time)=>sum + time, 0) / times.length;
    }
    clear(label) {
        if (label) {
            this.measurements.delete(label);
        } else {
            this.measurements.clear();
        }
    }
}


/***/ }),

/***/ "../../packages/react/src/hooks/useInteractiveGlass.ts":
/*!*************************************************************!*\
  !*** ../../packages/react/src/hooks/useInteractiveGlass.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   useInteractiveGlass: () => (/* binding */ useInteractiveGlass)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _liquid_ui_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @liquid-ui/core */ "../../packages/core/src/index.ts");


/**
 * useInteractiveGlass - Hook for interactive glass physics effects
 * 
 * This hook handles mouse interactions and applies Apple's liquid glass
 * physics calculations for realistic refraction and hover effects.
 */ function useInteractiveGlass({ elementRef, enabled = true, onHover, throttleMs = 16 // ~60fps
 }) {
    const engine = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(_liquid_ui_core__WEBPACK_IMPORTED_MODULE_1__.LiquidGlassEngine.getInstance());
    const isHoveredRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);
    // Throttled mouse move handler for performance
    const throttledMouseMove = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((0,_liquid_ui_core__WEBPACK_IMPORTED_MODULE_1__.throttle)((mousePosition)=>{
        if (!enabled || !elementRef.current) return;
        const element = elementRef.current;
        const bounds = element.getBoundingClientRect();
        // Calculate refraction intensity using Apple's formula
        const refraction = engine.current.calculateRefraction(mousePosition, {
            x: bounds.left,
            y: bounds.top,
            width: bounds.width,
            height: bounds.height
        });
        // Apply subtle transform based on refraction
        const transformX = (mousePosition.x - bounds.left - bounds.width / 2) / bounds.width * 10;
        const transformY = (mousePosition.y - bounds.top - bounds.height / 2) / bounds.height * 10;
        // Update element style with physics-based transforms
        element.style.transform = `perspective(1000px) rotateX(${-transformY * refraction}deg) rotateY(${transformX * refraction}deg) translateZ(${refraction * 5}px)`;
    }, throttleMs), [
        enabled,
        elementRef,
        throttleMs
    ]);
    const handleMouseEnter = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{
        if (!enabled) return;
        isHoveredRef.current = true;
        onHover?.(true);
        if (elementRef.current) {
            elementRef.current.style.transition = 'transform 0.2s cubic-bezier(0.23, 1, 0.32, 1)';
        }
    }, [
        enabled,
        onHover,
        elementRef
    ]);
    const handleMouseLeave = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{
        if (!enabled) return;
        isHoveredRef.current = false;
        onHover?.(false);
        if (elementRef.current) {
            // Reset transform with smooth transition
            elementRef.current.style.transform = 'perspective(1000px) rotateX(0deg) rotateY(0deg) translateZ(0px)';
            // Clean up transition after animation
            setTimeout(()=>{
                if (elementRef.current && !isHoveredRef.current) {
                    elementRef.current.style.transition = '';
                }
            }, 200);
        }
    }, [
        enabled,
        onHover,
        elementRef
    ]);
    const handleMouseMove = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{
        if (!enabled) return;
        const mousePosition = {
            x: e.clientX,
            y: e.clientY
        };
        throttledMouseMove(mousePosition);
    }, [
        enabled,
        throttledMouseMove
    ]);
    return {
        handleMouseEnter,
        handleMouseLeave,
        handleMouseMove
    };
}


/***/ }),

/***/ "../../packages/react/src/hooks/useLiquidGlass.ts":
/*!********************************************************!*\
  !*** ../../packages/react/src/hooks/useLiquidGlass.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   useLiquidGlass: () => (/* binding */ useLiquidGlass)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _liquid_ui_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @liquid-ui/core */ "../../packages/core/src/index.ts");


/**
 * useLiquidGlass - Hook for generating liquid glass CSS styles
 * 
 * This hook provides the core liquid glass styling by leveraging the
 * LiquidGlassEngine to generate optimized CSS properties.
 * 
 * Includes hydration safety to prevent SSR/client mismatches.
 */ function useLiquidGlass(config) {
    const [isClient, setIsClient] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);
    const engine = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>_liquid_ui_core__WEBPACK_IMPORTED_MODULE_1__.LiquidGlassEngine.getInstance(), []);
    // Hydration safety: only enable client-specific features after mounting
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{
        setIsClient(true);
    }, []);
    const styles = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{
        // Force server-side compatible rendering until client mount
        const serverSafeConfig = isClient ? config : {
            ...config,
            interactive: false
        };
        return engine.generateGlassCSS(serverSafeConfig);
    }, [
        engine,
        config,
        isClient
    ]);
    return styles;
}


/***/ })

}]);
//# sourceMappingURL=packages_react_src_hooks_useInteractiveGlass_ts-packages_react_src_hooks_useLiquidGlass_ts.iframe.bundle.js.map