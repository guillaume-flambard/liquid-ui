{"version":3,"file":"packages_react_src_hooks_useInteractiveGlass_ts-packages_react_src_hooks_useLiquidGlass_ts.iframe.bundle.js","mappings":";;;;;;;;;;;;;;AAAA;AAGA;;;;;;;;AAQA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAIA;AAEA;AACA;AACA;AAEA;;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtOA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACHA;;;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpFA;;AAEA;;AAIA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;AAEA;AAEA;AACA;AAEA;;AAEA;AAEA;AACA;AAEA;;AAEA;AAEA;AACA;AAEA;;AAEA;AAEA;AACA;AACA;AAEA;;AAEA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AAKA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AACA;AAMA;AAEA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AAEA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC1NA;AACA;AAUA;;;;;AAKA;AAKA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACrGA;AACA;AAGA;;;;;;;AAOA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA","sources":["webpack://@liquid-ui/storybook/../../packages/core/src/engine.ts","webpack://@liquid-ui/storybook/../../packages/core/src/index.ts","webpack://@liquid-ui/storybook/../../packages/core/src/tokens.ts","webpack://@liquid-ui/storybook/../../packages/core/src/utils.ts","webpack://@liquid-ui/storybook/../../packages/react/src/hooks/useInteractiveGlass.ts","webpack://@liquid-ui/storybook/../../packages/react/src/hooks/useLiquidGlass.ts"],"sourcesContent":["import { liquidTokens } from './tokens'\nimport type { Point, Rect, GlassConfig, LiquidGlassStyles, DeviceCapabilities } from './types'\n\n/**\n * LiquidGlassEngine - The core engine for Apple-style liquid glass effects\n * \n * This class implements Apple's exact liquid glass specifications including:\n * - Real-time refraction physics based on mouse position\n * - Adaptive opacity based on background luminance\n * - Performance-optimized CSS generation\n * - Cross-browser fallbacks\n */\nexport class LiquidGlassEngine {\n  private static instance: LiquidGlassEngine\n  private deviceCapabilities: DeviceCapabilities\n\n  constructor() {\n    this.deviceCapabilities = this.detectDeviceCapabilities()\n  }\n\n  static getInstance(): LiquidGlassEngine {\n    if (!LiquidGlassEngine.instance) {\n      LiquidGlassEngine.instance = new LiquidGlassEngine()\n    }\n    return LiquidGlassEngine.instance\n  }\n\n  /**\n   * Calculate refraction intensity based on mouse position\n   * Uses Apple's official formula: 1.0 - normalizedDist²\n   */\n  calculateRefraction(mousePosition: Point, elementBounds: Rect): number {\n    const centerX = elementBounds.x + elementBounds.width / 2\n    const centerY = elementBounds.y + elementBounds.height / 2\n    \n    const deltaX = mousePosition.x - centerX\n    const deltaY = mousePosition.y - centerY\n    \n    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY)\n    const maxDistance = Math.sqrt(\n      (elementBounds.width / 2) ** 2 + (elementBounds.height / 2) ** 2\n    )\n    \n    const normalizedDistance = Math.min(distance / maxDistance, 1)\n    \n    // Apple's refraction formula\n    return 1.0 - Math.pow(normalizedDistance, 2)\n  }\n\n  /**\n   * Generate optimized CSS properties for liquid glass effect\n   */\n  generateGlassCSS(config: GlassConfig): LiquidGlassStyles {\n    const { glass } = liquidTokens\n    \n    const blurValue = this.getBlurValue(config)\n    const backgroundValue = this.getBackgroundValue(config)\n    const borderValue = this.getBorderValue(config)\n    const shadowValue = this.getShadowValue(config)\n\n    const styles: LiquidGlassStyles = {\n      backdropFilter: `blur(${blurValue})`,\n      background: backgroundValue\n    }\n\n    // Add optional properties\n    if (borderValue) styles.border = borderValue\n    if (shadowValue) styles.boxShadow = shadowValue\n\n    // Add fallbacks for unsupported browsers\n    if (!this.deviceCapabilities.supportsBackdropFilter) {\n      styles.background = this.getFallbackBackground(config)\n    }\n\n    return styles\n  }\n\n  /**\n   * Get adaptive background based on environment luminance\n   */\n  getAdaptiveBackground(config: GlassConfig, backgroundLuminance: number): string {\n    const { glass } = liquidTokens\n    const baseColor = glass.colors[config.variant]\n    \n    // Adjust opacity based on background brightness\n    const luminanceMultiplier = backgroundLuminance > 0.5 ? 0.8 : 1.2\n    const adaptiveOpacity = glass.opacity[config.opacity] * luminanceMultiplier\n    \n    return this.adjustOpacity(baseColor, adaptiveOpacity)\n  }\n\n  /**\n   * Detect device capabilities for performance optimization\n   * Returns consistent values for SSR compatibility\n   */\n  private detectDeviceCapabilities(): DeviceCapabilities {\n    if (typeof window === 'undefined') {\n      // Server-side rendering fallback - assume modern browser support\n      return {\n        supportsBackdropFilter: true, // Assume support for SSR consistency\n        performanceLevel: 'medium',\n        reducedMotion: false\n      }\n    }\n\n    const testElement = document.createElement('div')\n    testElement.style.backdropFilter = 'blur(1px)'\n    \n    const supportsBackdropFilter = testElement.style.backdropFilter !== ''\n    \n    // Detect reduced motion preference\n    const reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches\n    \n    // Simple performance detection based on device memory and connection\n    const performanceLevel = this.detectPerformanceLevel()\n\n    return {\n      supportsBackdropFilter,\n      performanceLevel,\n      reducedMotion\n    }\n  }\n\n  private detectPerformanceLevel(): 'low' | 'medium' | 'high' {\n    if (typeof navigator === 'undefined') return 'medium'\n    \n    // Check device memory (if available)\n    const deviceMemory = (navigator as any).deviceMemory\n    if (deviceMemory) {\n      if (deviceMemory <= 2) return 'low'\n      if (deviceMemory >= 8) return 'high'\n    }\n    \n    // Check connection (if available)\n    const connection = (navigator as any).connection\n    if (connection) {\n      if (connection.effectiveType === '2g' || connection.effectiveType === 'slow-2g') {\n        return 'low'\n      }\n      if (connection.effectiveType === '4g') {\n        return 'high'\n      }\n    }\n    \n    return 'medium'\n  }\n\n  private getBlurValue(config: GlassConfig): string {\n    const { glass } = liquidTokens\n    \n    // Reduce blur on low-performance devices\n    if (this.deviceCapabilities.performanceLevel === 'low') {\n      return glass.blur.subtle\n    }\n    \n    return glass.blur[config.intensity]\n  }\n\n  private getBackgroundValue(config: GlassConfig): string {\n    const { glass } = liquidTokens\n    const baseColor = glass.colors[config.variant] || glass.colors.frosted\n    const opacity = glass.opacity[config.opacity] || glass.opacity.regular\n    \n    return this.adjustOpacity(baseColor, opacity)\n  }\n\n  private getBorderValue(config: GlassConfig): string | undefined {\n    const { glass } = liquidTokens\n    \n    if (config.variant === 'clear') return undefined\n    \n    return glass.border.subtle\n  }\n\n  private getShadowValue(config: GlassConfig): string | undefined {\n    const { glass } = liquidTokens\n    \n    if (this.deviceCapabilities.performanceLevel === 'low') {\n      return undefined // Skip shadows on low-performance devices\n    }\n    \n    switch (config.opacity) {\n      case 'light':\n        return glass.shadow.subtle\n      case 'regular':\n        return glass.shadow.regular\n      case 'strong':\n        return glass.shadow.strong\n      default:\n        return glass.shadow.regular\n    }\n  }\n\n  private getFallbackBackground(config: GlassConfig): string {\n    // Fallback for browsers that don't support backdrop-filter\n    const { glass } = liquidTokens\n    const fallbackOpacity = (glass.opacity[config.opacity] || glass.opacity.regular) * 1.5 // Increase opacity for visibility\n    \n    switch (config.variant) {\n      case 'clear':\n        return `rgba(255, 255, 255, ${fallbackOpacity})`\n      case 'frosted':\n        return `rgba(248, 250, 252, ${fallbackOpacity})`\n      case 'tinted':\n        return `rgba(219, 234, 254, ${fallbackOpacity})`\n      case 'dark':\n        return `rgba(15, 23, 42, ${fallbackOpacity})`\n      case 'aurora':\n        return `rgba(147, 51, 234, ${fallbackOpacity})`\n      case 'solid':\n        return `rgba(255, 255, 255, ${Math.min(fallbackOpacity * 2, 0.95)})`\n      default:\n        return `rgba(255, 255, 255, ${fallbackOpacity})`\n    }\n  }\n\n  private adjustOpacity(colorString: string | undefined, newOpacity: number): string {\n    if (!colorString) return `rgba(255, 255, 255, ${newOpacity})`\n    \n    // Extract rgba values and replace opacity\n    const rgbaMatch = colorString.match(/rgba?\\(([^)]+)\\)/)\n    if (!rgbaMatch) return colorString\n    \n    const values = rgbaMatch[1].split(',').map(v => v.trim())\n    if (values.length >= 3) {\n      return `rgba(${values[0]}, ${values[1]}, ${values[2]}, ${newOpacity})`\n    }\n    \n    return colorString\n  }\n}","export * from './tokens'\nexport * from './engine'\nexport * from './types'\nexport * from './utils'","/**\n * Liquid UI Design Tokens\n * Based on Apple's Liquid Glass specifications\n */\n\nexport const liquidTokens = {\n  glass: {\n    blur: {\n      subtle: '5px',    // Light blur for subtle glass effects\n      regular: '12px',  // Standard Apple glass blur\n      strong: '20px',   // Maximum blur for dramatic effects\n      none: '0px'       // Disable blur (fallback)\n    },\n    opacity: {\n      light: 0.15,      // 15% - Apple minimum for glass\n      regular: 0.25,    // 25% - Balanced transparency\n      medium: 0.45,     // 45% - More solid appearance\n      strong: 0.85      // 85% - Apple maximum for glass\n    },\n    physics: {\n      // Official Apple refraction formula: 1.0 - normalizedDist²\n      refraction: 'cubic-bezier(0.23, 1, 0.32, 1)',\n      spring: {\n        tension: 300,\n        friction: 30\n      },\n      hover: {\n        duration: '0.2s',\n        easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'\n      }\n    },\n    colors: {\n      // Glass tint colors for different variants\n      clear: 'rgba(255, 255, 255, 0)',\n      frosted: 'rgba(255, 255, 255, 0.1)',\n      tinted: 'rgba(0, 122, 255, 0.1)',\n      dark: 'rgba(0, 0, 0, 0.1)',\n      aurora: 'rgba(147, 51, 234, 0.1)', // Purple tint for aurora\n      solid: 'rgba(255, 255, 255, 0.95)' // Nearly opaque for solid\n    },\n    border: {\n      subtle: '1px solid rgba(255, 255, 255, 0.1)',\n      regular: '1px solid rgba(255, 255, 255, 0.2)',\n      strong: '1px solid rgba(255, 255, 255, 0.3)'\n    },\n    shadow: {\n      subtle: '0 4px 16px rgba(0, 0, 0, 0.1)',\n      regular: '0 8px 32px rgba(0, 0, 0, 0.15)',\n      strong: '0 16px 64px rgba(0, 0, 0, 0.2)'\n    }\n  },\n  spacing: {\n    xs: '0.25rem',   // 4px\n    sm: '0.5rem',    // 8px\n    md: '1rem',      // 16px\n    lg: '1.5rem',    // 24px\n    xl: '2rem',      // 32px\n    xxl: '3rem'      // 48px\n  },\n  borderRadius: {\n    sm: '0.375rem',  // 6px\n    md: '0.5rem',    // 8px\n    lg: '0.75rem',   // 12px\n    xl: '1rem',      // 16px\n    xxl: '1.5rem',   // 24px\n    full: '9999px'\n  },\n  typography: {\n    fontFamily: {\n      system: '-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif'\n    },\n    fontSize: {\n      xs: '0.75rem',\n      sm: '0.875rem',\n      base: '1rem',\n      lg: '1.125rem',\n      xl: '1.25rem',\n      xxl: '1.5rem'\n    },\n    fontWeight: {\n      normal: 400,\n      medium: 500,\n      semibold: 600,\n      bold: 700\n    }\n  }\n} as const\n\n// Type helpers for better TypeScript support\nexport type LiquidTokens = typeof liquidTokens\nexport type GlassVariant = 'clear' | 'frosted' | 'tinted' | 'dark' | 'aurora' | 'solid'\nexport type BlurIntensity = 'subtle' | 'regular' | 'strong' | 'none'\nexport type OpacityLevel = 'light' | 'regular' | 'medium' | 'strong'","import type { Point, Rect, DeviceCapabilities } from './types'\n\n/**\n * Utility functions for liquid glass calculations and optimizations\n */\n\n/**\n * Calculate distance between two points\n */\nexport function getDistanceFromCenter(point: Point, bounds: Rect): number {\n  const centerX = bounds.x + bounds.width / 2\n  const centerY = bounds.y + bounds.height / 2\n  \n  const deltaX = point.x - centerX\n  const deltaY = point.y - centerY\n  \n  return Math.sqrt(deltaX * deltaX + deltaY * deltaY)\n}\n\n/**\n * Normalize a value between 0 and 1\n */\nexport function normalize(value: number, min: number, max: number): number {\n  return Math.max(0, Math.min(1, (value - min) / (max - min)))\n}\n\n/**\n * Linear interpolation between two values\n */\nexport function lerp(start: number, end: number, t: number): number {\n  return start + (end - start) * t\n}\n\n/**\n * Apply easing function to a normalized value (0-1)\n */\nexport function easeOutCubic(t: number): number {\n  return 1 - Math.pow(1 - t, 3)\n}\n\n/**\n * Apply Apple's signature easing curve\n */\nexport function appleEasing(t: number): number {\n  // Cubic bezier (0.23, 1, 0.32, 1) approximation\n  return t * t * (3 - 2 * t)\n}\n\n/**\n * Calculate background luminance for adaptive opacity\n */\nexport function calculateLuminance(r: number, g: number, b: number): number {\n  // Convert to relative luminance using sRGB coefficients\n  const [rs, gs, bs] = [r, g, b].map(c => {\n    c = c / 255\n    return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4)\n  })\n  \n  return 0.2126 * rs + 0.7152 * gs + 0.0722 * bs\n}\n\n/**\n * Debounce function for performance optimization\n */\nexport function debounce<T extends (...args: any[]) => void>(\n  func: T,\n  wait: number\n): (...args: Parameters<T>) => void {\n  let timeout: NodeJS.Timeout | undefined\n  \n  return (...args: Parameters<T>) => {\n    clearTimeout(timeout)\n    timeout = setTimeout(() => func(...args), wait)\n  }\n}\n\n/**\n * Throttle function for smooth animations\n */\nexport function throttle<T extends (...args: any[]) => void>(\n  func: T,\n  limit: number\n): (...args: Parameters<T>) => void {\n  let inThrottle: boolean\n  \n  return (...args: Parameters<T>) => {\n    if (!inThrottle) {\n      func(...args)\n      inThrottle = true\n      setTimeout(() => inThrottle = false, limit)\n    }\n  }\n}\n\n/**\n * Check if an element is in viewport\n */\nexport function isInViewport(element: Element): boolean {\n  const rect = element.getBoundingClientRect()\n  return (\n    rect.top >= 0 &&\n    rect.left >= 0 &&\n    rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&\n    rect.right <= (window.innerWidth || document.documentElement.clientWidth)\n  )\n}\n\n/**\n * Get element bounds relative to viewport\n */\nexport function getElementBounds(element: Element): Rect {\n  const rect = element.getBoundingClientRect()\n  return {\n    x: rect.left,\n    y: rect.top,\n    width: rect.width,\n    height: rect.height\n  }\n}\n\n/**\n * Convert CSS color string to RGB values\n */\nexport function parseColor(colorString: string): { r: number; g: number; b: number } | null {\n  // Handle rgba/rgb format\n  const rgbaMatch = colorString.match(/rgba?\\(([^)]+)\\)/)\n  if (rgbaMatch) {\n    const values = rgbaMatch[1].split(',').map(v => parseInt(v.trim(), 10))\n    if (values.length >= 3) {\n      return { r: values[0], g: values[1], b: values[2] }\n    }\n  }\n  \n  // Handle hex format\n  const hexMatch = colorString.match(/^#([a-f\\d]{6})$/i)\n  if (hexMatch) {\n    const hex = hexMatch[1]\n    return {\n      r: parseInt(hex.substr(0, 2), 16),\n      g: parseInt(hex.substr(2, 2), 16),\n      b: parseInt(hex.substr(4, 2), 16)\n    }\n  }\n  \n  return null\n}\n\n/**\n * Generate CSS custom properties object from tokens\n */\nexport function generateCSSCustomProperties(tokens: Record<string, any>, prefix = '--liquid'): Record<string, string> {\n  const properties: Record<string, string> = {}\n  \n  function flatten(obj: any, path: string[] = []): void {\n    for (const [key, value] of Object.entries(obj)) {\n      const currentPath = [...path, key]\n      \n      if (typeof value === 'object' && value !== null && !Array.isArray(value)) {\n        flatten(value, currentPath)\n      } else {\n        const propertyName = `${prefix}-${currentPath.join('-')}`\n        properties[propertyName] = String(value)\n      }\n    }\n  }\n  \n  flatten(tokens)\n  return properties\n}\n\n/**\n * Performance monitor for development\n */\nexport class PerformanceMonitor {\n  private measurements: Map<string, number[]> = new Map()\n  \n  start(label: string): void {\n    if (typeof performance !== 'undefined') {\n      performance.mark(`${label}-start`)\n    }\n  }\n  \n  end(label: string): number {\n    if (typeof performance === 'undefined') return 0\n    \n    performance.mark(`${label}-end`)\n    performance.measure(label, `${label}-start`, `${label}-end`)\n    \n    const entries = performance.getEntriesByName(label, 'measure')\n    if (entries.length > 0) {\n      const duration = entries[entries.length - 1].duration\n      \n      // Store measurement for analysis\n      if (!this.measurements.has(label)) {\n        this.measurements.set(label, [])\n      }\n      this.measurements.get(label)!.push(duration)\n      \n      return duration\n    }\n    \n    return 0\n  }\n  \n  getAverageTime(label: string): number {\n    const times = this.measurements.get(label)\n    if (!times || times.length === 0) return 0\n    \n    return times.reduce((sum, time) => sum + time, 0) / times.length\n  }\n  \n  clear(label?: string): void {\n    if (label) {\n      this.measurements.delete(label)\n    } else {\n      this.measurements.clear()\n    }\n  }\n}","import { useCallback, useRef, type RefObject } from 'react'\nimport { LiquidGlassEngine, throttle } from '@liquid-ui/core'\nimport type { Point } from '@liquid-ui/core'\n\ninterface UseInteractiveGlassProps {\n  elementRef: RefObject<HTMLElement>\n  enabled?: boolean\n  onHover?: (isHovered: boolean) => void\n  throttleMs?: number\n}\n\n/**\n * useInteractiveGlass - Hook for interactive glass physics effects\n * \n * This hook handles mouse interactions and applies Apple's liquid glass\n * physics calculations for realistic refraction and hover effects.\n */\nexport function useInteractiveGlass({\n  elementRef,\n  enabled = true,\n  onHover,\n  throttleMs = 16 // ~60fps\n}: UseInteractiveGlassProps) {\n  const engine = useRef(LiquidGlassEngine.getInstance())\n  const isHoveredRef = useRef(false)\n  \n  // Throttled mouse move handler for performance\n  const throttledMouseMove = useCallback(\n    throttle((mousePosition: Point) => {\n      if (!enabled || !elementRef.current) return\n      \n      const element = elementRef.current\n      const bounds = element.getBoundingClientRect()\n      \n      // Calculate refraction intensity using Apple's formula\n      const refraction = engine.current.calculateRefraction(\n        mousePosition,\n        {\n          x: bounds.left,\n          y: bounds.top,\n          width: bounds.width,\n          height: bounds.height\n        }\n      )\n      \n      // Apply subtle transform based on refraction\n      const transformX = (mousePosition.x - bounds.left - bounds.width / 2) / bounds.width * 10\n      const transformY = (mousePosition.y - bounds.top - bounds.height / 2) / bounds.height * 10\n      \n      // Update element style with physics-based transforms\n      element.style.transform = `perspective(1000px) rotateX(${-transformY * refraction}deg) rotateY(${transformX * refraction}deg) translateZ(${refraction * 5}px)`\n    }, throttleMs),\n    [enabled, elementRef, throttleMs]\n  )\n  \n  const handleMouseEnter = useCallback(() => {\n    if (!enabled) return\n    \n    isHoveredRef.current = true\n    onHover?.(true)\n    \n    if (elementRef.current) {\n      elementRef.current.style.transition = 'transform 0.2s cubic-bezier(0.23, 1, 0.32, 1)'\n    }\n  }, [enabled, onHover, elementRef])\n  \n  const handleMouseLeave = useCallback(() => {\n    if (!enabled) return\n    \n    isHoveredRef.current = false\n    onHover?.(false)\n    \n    if (elementRef.current) {\n      // Reset transform with smooth transition\n      elementRef.current.style.transform = 'perspective(1000px) rotateX(0deg) rotateY(0deg) translateZ(0px)'\n      \n      // Clean up transition after animation\n      setTimeout(() => {\n        if (elementRef.current && !isHoveredRef.current) {\n          elementRef.current.style.transition = ''\n        }\n      }, 200)\n    }\n  }, [enabled, onHover, elementRef])\n  \n  const handleMouseMove = useCallback((e: React.MouseEvent) => {\n    if (!enabled) return\n    \n    const mousePosition: Point = {\n      x: e.clientX,\n      y: e.clientY\n    }\n    \n    throttledMouseMove(mousePosition)\n  }, [enabled, throttledMouseMove])\n  \n  return {\n    handleMouseEnter,\n    handleMouseLeave,\n    handleMouseMove\n  }\n}","import { useMemo, useEffect, useState } from 'react'\nimport { LiquidGlassEngine } from '@liquid-ui/core'\nimport type { GlassConfig } from '@liquid-ui/core'\n\n/**\n * useLiquidGlass - Hook for generating liquid glass CSS styles\n * \n * This hook provides the core liquid glass styling by leveraging the\n * LiquidGlassEngine to generate optimized CSS properties.\n * \n * Includes hydration safety to prevent SSR/client mismatches.\n */\nexport function useLiquidGlass(config: GlassConfig) {\n  const [isClient, setIsClient] = useState(false)\n  const engine = useMemo(() => LiquidGlassEngine.getInstance(), [])\n  \n  // Hydration safety: only enable client-specific features after mounting\n  useEffect(() => {\n    setIsClient(true)\n  }, [])\n  \n  const styles = useMemo(() => {\n    // Force server-side compatible rendering until client mount\n    const serverSafeConfig = isClient ? config : { ...config, interactive: false }\n    return engine.generateGlassCSS(serverSafeConfig)\n  }, [engine, config, isClient])\n  \n  return styles\n}"],"names":[],"sourceRoot":""}