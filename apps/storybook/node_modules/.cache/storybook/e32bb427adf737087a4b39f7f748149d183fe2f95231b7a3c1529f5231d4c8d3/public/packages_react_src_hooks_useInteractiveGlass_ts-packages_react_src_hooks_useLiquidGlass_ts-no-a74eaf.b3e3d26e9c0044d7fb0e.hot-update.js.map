{"version":3,"file":"packages_react_src_hooks_useInteractiveGlass_ts-packages_react_src_hooks_useLiquidGlass_ts-no-a74eaf.b3e3d26e9c0044d7fb0e.hot-update.js","mappings":";;;;;;;;;;;;;;AAAA;AAGA;;;;;;;;AAQA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAIA;AAEA;AACA;AACA;AAEA;;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA","sources":["webpack://@liquid-ui/storybook/../../packages/core/src/engine.ts"],"sourcesContent":["import { liquidTokens } from './tokens'\nimport type { Point, Rect, GlassConfig, LiquidGlassStyles, DeviceCapabilities } from './types'\n\n/**\n * LiquidGlassEngine - The core engine for Apple-style liquid glass effects\n * \n * This class implements Apple's exact liquid glass specifications including:\n * - Real-time refraction physics based on mouse position\n * - Adaptive opacity based on background luminance\n * - Performance-optimized CSS generation\n * - Cross-browser fallbacks\n */\nexport class LiquidGlassEngine {\n  private static instance: LiquidGlassEngine\n  private deviceCapabilities: DeviceCapabilities\n\n  constructor() {\n    this.deviceCapabilities = this.detectDeviceCapabilities()\n  }\n\n  static getInstance(): LiquidGlassEngine {\n    if (!LiquidGlassEngine.instance) {\n      LiquidGlassEngine.instance = new LiquidGlassEngine()\n    }\n    return LiquidGlassEngine.instance\n  }\n\n  /**\n   * Calculate refraction intensity based on mouse position\n   * Uses Apple's official formula: 1.0 - normalizedDistÂ²\n   */\n  calculateRefraction(mousePosition: Point, elementBounds: Rect): number {\n    const centerX = elementBounds.x + elementBounds.width / 2\n    const centerY = elementBounds.y + elementBounds.height / 2\n    \n    const deltaX = mousePosition.x - centerX\n    const deltaY = mousePosition.y - centerY\n    \n    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY)\n    const maxDistance = Math.sqrt(\n      (elementBounds.width / 2) ** 2 + (elementBounds.height / 2) ** 2\n    )\n    \n    const normalizedDistance = Math.min(distance / maxDistance, 1)\n    \n    // Apple's refraction formula\n    return 1.0 - Math.pow(normalizedDistance, 2)\n  }\n\n  /**\n   * Generate optimized CSS properties for liquid glass effect\n   */\n  generateGlassCSS(config: GlassConfig): LiquidGlassStyles {\n    const { glass } = liquidTokens\n    \n    const blurValue = this.getBlurValue(config)\n    const backgroundValue = this.getBackgroundValue(config)\n    const borderValue = this.getBorderValue(config)\n    const shadowValue = this.getShadowValue(config)\n\n    const styles: LiquidGlassStyles = {\n      backdropFilter: `blur(${blurValue})`,\n      background: backgroundValue\n    }\n\n    // Add optional properties\n    if (borderValue) styles.border = borderValue\n    if (shadowValue) styles.boxShadow = shadowValue\n\n    // Add fallbacks for unsupported browsers\n    if (!this.deviceCapabilities.supportsBackdropFilter) {\n      styles.background = this.getFallbackBackground(config)\n    }\n\n    return styles\n  }\n\n  /**\n   * Get adaptive background based on environment luminance\n   */\n  getAdaptiveBackground(config: GlassConfig, backgroundLuminance: number): string {\n    const { glass } = liquidTokens\n    const baseColor = glass.colors[config.variant]\n    \n    // Adjust opacity based on background brightness\n    const luminanceMultiplier = backgroundLuminance > 0.5 ? 0.8 : 1.2\n    const adaptiveOpacity = glass.opacity[config.opacity] * luminanceMultiplier\n    \n    return this.adjustOpacity(baseColor, adaptiveOpacity)\n  }\n\n  /**\n   * Detect device capabilities for performance optimization\n   */\n  private detectDeviceCapabilities(): DeviceCapabilities {\n    if (typeof window === 'undefined') {\n      // Server-side rendering fallback\n      return {\n        supportsBackdropFilter: false,\n        performanceLevel: 'medium',\n        reducedMotion: false\n      }\n    }\n\n    const testElement = document.createElement('div')\n    testElement.style.backdropFilter = 'blur(1px)'\n    \n    const supportsBackdropFilter = testElement.style.backdropFilter !== ''\n    \n    // Detect reduced motion preference\n    const reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches\n    \n    // Simple performance detection based on device memory and connection\n    const performanceLevel = this.detectPerformanceLevel()\n\n    return {\n      supportsBackdropFilter,\n      performanceLevel,\n      reducedMotion\n    }\n  }\n\n  private detectPerformanceLevel(): 'low' | 'medium' | 'high' {\n    if (typeof navigator === 'undefined') return 'medium'\n    \n    // Check device memory (if available)\n    const deviceMemory = (navigator as any).deviceMemory\n    if (deviceMemory) {\n      if (deviceMemory <= 2) return 'low'\n      if (deviceMemory >= 8) return 'high'\n    }\n    \n    // Check connection (if available)\n    const connection = (navigator as any).connection\n    if (connection) {\n      if (connection.effectiveType === '2g' || connection.effectiveType === 'slow-2g') {\n        return 'low'\n      }\n      if (connection.effectiveType === '4g') {\n        return 'high'\n      }\n    }\n    \n    return 'medium'\n  }\n\n  private getBlurValue(config: GlassConfig): string {\n    const { glass } = liquidTokens\n    \n    // Reduce blur on low-performance devices\n    if (this.deviceCapabilities.performanceLevel === 'low') {\n      return glass.blur.subtle\n    }\n    \n    return glass.blur[config.intensity]\n  }\n\n  private getBackgroundValue(config: GlassConfig): string {\n    const { glass } = liquidTokens\n    const baseColor = glass.colors[config.variant] || glass.colors.frosted\n    const opacity = glass.opacity[config.opacity] || glass.opacity.regular\n    \n    return this.adjustOpacity(baseColor, opacity)\n  }\n\n  private getBorderValue(config: GlassConfig): string | undefined {\n    const { glass } = liquidTokens\n    \n    if (config.variant === 'clear') return undefined\n    \n    return glass.border.subtle\n  }\n\n  private getShadowValue(config: GlassConfig): string | undefined {\n    const { glass } = liquidTokens\n    \n    if (this.deviceCapabilities.performanceLevel === 'low') {\n      return undefined // Skip shadows on low-performance devices\n    }\n    \n    switch (config.opacity) {\n      case 'light':\n        return glass.shadow.subtle\n      case 'regular':\n        return glass.shadow.regular\n      case 'strong':\n        return glass.shadow.strong\n      default:\n        return glass.shadow.regular\n    }\n  }\n\n  private getFallbackBackground(config: GlassConfig): string {\n    // Fallback for browsers that don't support backdrop-filter\n    const { glass } = liquidTokens\n    const fallbackOpacity = (glass.opacity[config.opacity] || glass.opacity.regular) * 1.5 // Increase opacity for visibility\n    \n    switch (config.variant) {\n      case 'clear':\n        return `rgba(255, 255, 255, ${fallbackOpacity})`\n      case 'frosted':\n        return `rgba(248, 250, 252, ${fallbackOpacity})`\n      case 'tinted':\n        return `rgba(219, 234, 254, ${fallbackOpacity})`\n      case 'dark':\n        return `rgba(15, 23, 42, ${fallbackOpacity})`\n      case 'aurora':\n        return `rgba(147, 51, 234, ${fallbackOpacity})`\n      case 'solid':\n        return `rgba(255, 255, 255, ${Math.min(fallbackOpacity * 2, 0.95)})`\n      default:\n        return `rgba(255, 255, 255, ${fallbackOpacity})`\n    }\n  }\n\n  private adjustOpacity(colorString: string | undefined, newOpacity: number): string {\n    if (!colorString) return `rgba(255, 255, 255, ${newOpacity})`\n    \n    // Extract rgba values and replace opacity\n    const rgbaMatch = colorString.match(/rgba?\\(([^)]+)\\)/)\n    if (!rgbaMatch) return colorString\n    \n    const values = rgbaMatch[1].split(',').map(v => v.trim())\n    if (values.length >= 3) {\n      return `rgba(${values[0]}, ${values[1]}, ${values[2]}, ${newOpacity})`\n    }\n    \n    return colorString\n  }\n}"],"names":[],"sourceRoot":""}