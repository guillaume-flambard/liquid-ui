"use strict";
self["webpackHotUpdate_liquid_ui_storybook"]("packages_react_src_components_LiquidCard_tsx",{

/***/ "../../packages/react/src/components/LiquidCard.tsx":
/*!**********************************************************!*\
  !*** ../../packages/react/src/components/LiquidCard.tsx ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LiquidCard: () => (/* binding */ LiquidCard)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! clsx */ "../../node_modules/clsx/dist/clsx.mjs");
/* harmony import */ var _hooks_useLiquidGlass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../hooks/useLiquidGlass */ "../../packages/react/src/hooks/useLiquidGlass.ts");
/* harmony import */ var _hooks_useInteractiveGlass__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../hooks/useInteractiveGlass */ "../../packages/react/src/hooks/useInteractiveGlass.ts");




/**
 * LiquidCard - The signature Liquid UI component
 * 
 * A beautiful glass card with Apple-style liquid glass effects, perfect physics,
 * and smooth animations. This is the cornerstone component of Liquid UI.
 */ const LiquidCardBase = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ variant = 'frosted', intensity = 'regular', opacity = 'regular', interactive = true, adaptiveOpacity = false, environmentBlending = false, hover = true, shadow = true, border = true, className, children, onHover, onDragStart, onDrag, onDragEnd, draggable = false, magneticEdges = false, magneticStrength = 0.3, style, ...props }, ref)=>{
    const [isHovered, setIsHovered] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);
    const [dragState, setDragState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({
        isDragging: false,
        startX: 0,
        startY: 0,
        currentX: 0,
        currentY: 0
    });
    const [magneticEffect, setMagneticEffect] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({
        x: 0,
        y: 0,
        intensity: 0
    });
    const [shadowDepth, setShadowDepth] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);
    const cardRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
    // Use our custom hooks for glass effects
    const glassStyles = (0,_hooks_useLiquidGlass__WEBPACK_IMPORTED_MODULE_2__.useLiquidGlass)({
        variant,
        intensity,
        opacity,
        interactive,
        adaptiveOpacity,
        environmentBlending
    });
    const { handleMouseEnter, handleMouseLeave, handleMouseMove } = (0,_hooks_useInteractiveGlass__WEBPACK_IMPORTED_MODULE_3__.useInteractiveGlass)({
        elementRef: cardRef,
        enabled: interactive && hover && !dragState.isDragging,
        onHover: (hovered)=>{
            setIsHovered(hovered);
            onHover?.(hovered);
            if (hovered) {
                setShadowDepth(1);
            } else {
                setShadowDepth(0);
            }
        }
    });
    // Magnetic edges effect
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{
        if (!magneticEdges || !isHovered || dragState.isDragging) return;
        const handleMagneticMove = (e)=>{
            const card = cardRef.current;
            if (!card) return;
            const rect = card.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const deltaX = e.clientX - centerX;
            const deltaY = e.clientY - centerY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const maxDistance = Math.max(rect.width, rect.height) / 2;
            if (distance < maxDistance) {
                const intensity = (1 - distance / maxDistance) * magneticStrength;
                setMagneticEffect({
                    x: deltaX * intensity * 0.1,
                    y: deltaY * intensity * 0.1,
                    intensity
                });
            } else {
                setMagneticEffect({
                    x: 0,
                    y: 0,
                    intensity: 0
                });
            }
        };
        document.addEventListener('mousemove', handleMagneticMove);
        return ()=>document.removeEventListener('mousemove', handleMagneticMove);
    }, [
        magneticEdges,
        isHovered,
        dragState.isDragging,
        magneticStrength
    ]);
    // Drag functionality
    const handleDragStart = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{
        if (!draggable) return;
        e.preventDefault();
        const clientX = 'touches' in e ? e.touches[0].clientX : e.clientX;
        const clientY = 'touches' in e ? e.touches[0].clientY : e.clientY;
        setDragState({
            isDragging: true,
            startX: clientX,
            startY: clientY,
            currentX: 0,
            currentY: 0
        });
        setShadowDepth(2);
        onDragStart?.(e);
    }, [
        draggable,
        onDragStart
    ]);
    const handleDragMove = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{
        if (!dragState.isDragging) return;
        const clientX = 'touches' in e ? e.touches[0].clientX : e.clientX;
        const clientY = 'touches' in e ? e.touches[0].clientY : e.clientY;
        const deltaX = clientX - dragState.startX;
        const deltaY = clientY - dragState.startY;
        setDragState((prev)=>({
                ...prev,
                currentX: deltaX,
                currentY: deltaY
            }));
        onDrag?.(e, {
            x: deltaX,
            y: deltaY
        });
    }, [
        dragState.isDragging,
        dragState.startX,
        dragState.startY,
        onDrag
    ]);
    const handleDragEnd = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{
        if (!dragState.isDragging) return;
        setDragState({
            isDragging: false,
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0
        });
        setShadowDepth(0);
        setMagneticEffect({
            x: 0,
            y: 0,
            intensity: 0
        });
        onDragEnd?.(e);
    }, [
        dragState.isDragging,
        onDragEnd
    ]);
    // Global drag event listeners
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{
        if (dragState.isDragging) {
            document.addEventListener('mousemove', handleDragMove);
            document.addEventListener('mouseup', handleDragEnd);
            document.addEventListener('touchmove', handleDragMove);
            document.addEventListener('touchend', handleDragEnd);
            return ()=>{
                document.removeEventListener('mousemove', handleDragMove);
                document.removeEventListener('mouseup', handleDragEnd);
                document.removeEventListener('touchmove', handleDragMove);
                document.removeEventListener('touchend', handleDragEnd);
            };
        }
    }, [
        dragState.isDragging,
        handleDragMove,
        handleDragEnd
    ]);
    // Combine all mouse event handlers
    const onMouseEnter = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{
        if (!dragState.isDragging) {
            handleMouseEnter();
        }
        props.onMouseEnter?.(e);
    }, [
        handleMouseEnter,
        props.onMouseEnter,
        dragState.isDragging
    ]);
    const onMouseLeave = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{
        if (!dragState.isDragging) {
            handleMouseLeave();
            setMagneticEffect({
                x: 0,
                y: 0,
                intensity: 0
            });
        }
        props.onMouseLeave?.(e);
    }, [
        handleMouseLeave,
        props.onMouseLeave,
        dragState.isDragging
    ]);
    const onMouseMove = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{
        if (!dragState.isDragging) {
            handleMouseMove(e);
        }
        props.onMouseMove?.(e);
    }, [
        handleMouseMove,
        props.onMouseMove,
        dragState.isDragging
    ]);
    const onMouseDown = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{
        handleDragStart(e);
        props.onMouseDown?.(e);
    }, [
        handleDragStart,
        props.onMouseDown
    ]);
    const onTouchStart = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{
        handleDragStart(e);
        props.onTouchStart?.(e);
    }, [
        handleDragStart,
        props.onTouchStart
    ]);
    // Build CSS classes
    const classes = (0,clsx__WEBPACK_IMPORTED_MODULE_1__.clsx)(// Base glass card styles
    'liquid-card', 'relative', 'overflow-hidden', 'transition-all', 'duration-200', 'ease-out', // Border styles
    border && 'border border-white/10', // Dynamic shadow styles based on depth
    shadow && [
        shadowDepth === 0 && 'shadow-lg',
        shadowDepth === 1 && 'shadow-xl',
        shadowDepth === 2 && 'shadow-2xl',
        dragState.isDragging && 'shadow-2xl shadow-blue-500/25'
    ], // Interactive styles
    interactive && [
        !dragState.isDragging && 'cursor-pointer',
        'transform-gpu',
        'transition-all',
        'duration-300',
        'ease-out',
        hover && !dragState.isDragging && 'hover:scale-[1.02]',
        isHovered && !dragState.isDragging && 'scale-[1.02]'
    ], // Draggable styles
    draggable && [
        'select-none',
        dragState.isDragging && [
            'cursor-grabbing',
            'scale-105',
            'rotate-1',
            'z-50'
        ],
        !dragState.isDragging && draggable && 'cursor-grab'
    ], // Custom className
    className);
    // Merge styles with transforms
    const transformStyles = {
        transform: `
        translate3d(
          ${dragState.currentX + magneticEffect.x}px, 
          ${dragState.currentY + magneticEffect.y}px, 
          ${dragState.isDragging ? '10px' : '0px'}
        )
        ${dragState.isDragging ? 'rotateX(5deg) rotateY(2deg)' : ''}
        ${isHovered && !dragState.isDragging ? 'scale(1.02)' : ''}
      `.replace(/\s+/g, ' ').trim(),
        filter: [
            glassStyles.filter || '',
            dragState.isDragging ? 'brightness(1.1)' : '',
            magneticEffect.intensity > 0 ? `hue-rotate(${magneticEffect.intensity * 10}deg)` : ''
        ].filter(Boolean).join(' ')
    };
    const combinedStyles = {
        ...glassStyles,
        ...transformStyles,
        ...style
    };
    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", {
        ref: (node)=>{
            // Handle both forwarded ref and internal ref
            if (typeof ref === 'function') {
                ref(node);
            } else if (ref) {
                ref.current = node;
            }
            if (cardRef.current !== node) {
                cardRef.current = node;
            }
        },
        className: classes,
        style: combinedStyles,
        onMouseEnter: onMouseEnter,
        onMouseLeave: onMouseLeave,
        onMouseMove: onMouseMove,
        onMouseDown: onMouseDown,
        onTouchStart: onTouchStart,
        draggable: false,
        ...(({ onDragStart, onDrag, onDragEnd, magneticEdges, magneticStrength, ...rest })=>rest)(props)
    }, magneticEdges && magneticEffect.intensity > 0 && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", {
        className: "absolute inset-0 rounded-inherit pointer-events-none",
        style: {
            background: `radial-gradient(circle at center, 
                rgba(59, 130, 246, ${magneticEffect.intensity * 0.1}) 0%, 
                transparent 70%
              )`,
            opacity: magneticEffect.intensity
        }
    }), draggable && isHovered && !dragState.isDragging && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", {
        className: "absolute top-2 right-2 opacity-50 pointer-events-none"
    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement("svg", {
        className: "w-4 h-4 text-white",
        fill: "none",
        stroke: "currentColor",
        viewBox: "0 0 24 24"
    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        strokeWidth: 2,
        d: "M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"
    }))), children);
});
LiquidCardBase.displayName = 'LiquidCard';
// Create the main component with proper typing
const LiquidCard = LiquidCardBase;
// Preset components for easier usage
LiquidCard.Frosted = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((props, ref)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(LiquidCardBase, {
        ref: ref,
        variant: "frosted",
        intensity: "regular",
        interactive: true,
        hover: true,
        shadow: true,
        ...props
    }));
LiquidCard.Frosted.displayName = 'LiquidCard.Frosted';
LiquidCard.Clear = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((props, ref)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(LiquidCardBase, {
        ref: ref,
        variant: "clear",
        opacity: "light",
        interactive: true,
        hover: true,
        ...props
    }));
LiquidCard.Clear.displayName = 'LiquidCard.Clear';
LiquidCard.Tinted = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((props, ref)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(LiquidCardBase, {
        ref: ref,
        variant: "tinted",
        intensity: "regular",
        interactive: true,
        hover: true,
        shadow: true,
        ...props
    }));
LiquidCard.Tinted.displayName = 'LiquidCard.Tinted';
LiquidCard.Interactive = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((props, ref)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(LiquidCardBase, {
        ref: ref,
        interactive: true,
        hover: true,
        shadow: true,
        border: true,
        ...props
    }));
LiquidCard.Interactive.displayName = 'LiquidCard.Interactive';
LiquidCard.Static = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((props, ref)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(LiquidCardBase, {
        ref: ref,
        interactive: false,
        hover: false,
        shadow: false,
        ...props
    }));
LiquidCard.Static.displayName = 'LiquidCard.Static';

try {
    // @ts-ignore
    LiquidCard.displayName = "LiquidCard";
    // @ts-ignore
    LiquidCard.__docgenInfo = { "description": "", "displayName": "LiquidCard", "props": { "hover": { "defaultValue": { value: "true" }, "description": "", "name": "hover", "required": false, "type": { "name": "boolean" } }, "shadow": { "defaultValue": { value: "true" }, "description": "", "name": "shadow", "required": false, "type": { "name": "boolean" } }, "border": { "defaultValue": { value: "true" }, "description": "", "name": "border", "required": false, "type": { "name": "boolean" } }, "onHover": { "defaultValue": null, "description": "", "name": "onHover", "required": false, "type": { "name": "(isHovered: boolean) => void" } }, "draggable": { "defaultValue": { value: "false" }, "description": "", "name": "draggable", "required": false, "type": { "name": "boolean" } }, "magneticEdges": { "defaultValue": { value: "false" }, "description": "", "name": "magneticEdges", "required": false, "type": { "name": "boolean" } }, "magneticStrength": { "defaultValue": { value: "0.3" }, "description": "", "name": "magneticStrength", "required": false, "type": { "name": "number" } }, "onDragStart": { "defaultValue": null, "description": "", "name": "onDragStart", "required": false, "type": { "name": "(e: MouseEvent<Element, MouseEvent> | TouchEvent<Element>) => void" } }, "onDrag": { "defaultValue": null, "description": "", "name": "onDrag", "required": false, "type": { "name": "(e: MouseEvent | TouchEvent, position: { x: number; y: number; }) => void" } }, "onDragEnd": { "defaultValue": null, "description": "", "name": "onDragEnd", "required": false, "type": { "name": "(e: MouseEvent | TouchEvent) => void" } }, "variant": { "defaultValue": { value: "frosted" }, "description": "", "name": "variant", "required": false, "type": { "name": "enum", "value": [{ "value": "\"clear\"" }, { "value": "\"frosted\"" }, { "value": "\"tinted\"" }, { "value": "\"dark\"" }, { "value": "\"aurora\"" }, { "value": "\"solid\"" }] } }, "intensity": { "defaultValue": { value: "regular" }, "description": "", "name": "intensity", "required": false, "type": { "name": "enum", "value": [{ "value": "\"subtle\"" }, { "value": "\"regular\"" }, { "value": "\"strong\"" }, { "value": "\"none\"" }] } }, "opacity": { "defaultValue": { value: "regular" }, "description": "", "name": "opacity", "required": false, "type": { "name": "enum", "value": [{ "value": "\"regular\"" }, { "value": "\"strong\"" }, { "value": "\"light\"" }, { "value": "\"medium\"" }] } }, "interactive": { "defaultValue": { value: "true" }, "description": "", "name": "interactive", "required": false, "type": { "name": "boolean" } }, "adaptiveOpacity": { "defaultValue": { value: "false" }, "description": "", "name": "adaptiveOpacity", "required": false, "type": { "name": "boolean" } }, "environmentBlending": { "defaultValue": { value: "false" }, "description": "", "name": "environmentBlending", "required": false, "type": { "name": "boolean" } }, "className": { "defaultValue": null, "description": "", "name": "className", "required": false, "type": { "name": "string" } } } };
    // @ts-ignore
    if (typeof STORYBOOK_REACT_CLASSES !== "undefined")
        // @ts-ignore
        STORYBOOK_REACT_CLASSES["../../packages/react/src/components/LiquidCard.tsx#LiquidCard"] = { docgenInfo: LiquidCard.__docgenInfo, name: "LiquidCard", path: "../../packages/react/src/components/LiquidCard.tsx#LiquidCard" };
}
catch (__react_docgen_typescript_loader_error) { }

/***/ })

});
//# sourceMappingURL=packages_react_src_components_LiquidCard_tsx.ef4283c009eae94ebe37.hot-update.js.map